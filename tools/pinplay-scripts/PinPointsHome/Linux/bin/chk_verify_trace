#!/bin/bash
#
# Look for errors in the output from the runpinpoints.sh script & files generated by
# this script. 
#
# $Id: chk_verify_trace,v 1.17 2012/08/17 20:41:49 tmstall Exp tmstall $


function usage {

cat 1>&2 << END
Usage: $0 [output_file] [-h]
   output_file  output from runpinpoints.sh (default 'pinLIT_out.txt')
   -h           print this help message
END
}

# Get the output file to check.
#
export OUT_FILE="pinLIT_out.txt"
if [[ ! -z $1 ]]
then
   OUT_FILE=$1
   shift
fi
if [[ ! -f $OUT_FILE ]]
then
    echo "ERROR: Can't open file:"
    echo "    $OUT_FILE"
    usage
    exit 1
fi

# Parse command line options
#
while getopts "h" c
do
    case $c in
    h | \?)
        usage
        exit 0
        ;;
    esac
done

TMP_FILE="/tmp/tmp_$$"

# Execute a command to look for errors.  Only print out information if anything is 
# found.
#
# Global variables:
#    FILE    - file to use for the search
#    HEADER  - string describing what the error is
#    CMD     - command used to look for the error
#
function look_for_error()  {

    [[ ! -f $FILE ]] && return  # File not found, just return
    eval $CMD >& $TMP_FILE
    if [ $? == 0 ]
    then
	echo $HEADER
	echo "======================="
	cat $TMP_FILE
	echo
    fi
}

FILE=$OUT_FILE
HEADER="Error strings in script output:"
CMD='fgrep -i error $FILE | egrep -v "for any errors|sort: write error|NOTE: Ignore errors"'
look_for_error

FILE=$OUT_FILE
HEADER="Assertions or segv in script output:"
CMD='egrep -C 1 -i "abort|core dump|signal|assert|segv|Segmentation fault|^A:|icount for focus thread|an indication of an error|WARNING: Exceeded maximum number of times " $FILE'
look_for_error

FILE=`ls *lit/*log 2> /dev/null`
HEADER="Errors in LIT log files:"
CMD='fgrep -C 1 -i error $FILE'
look_for_error

FILE=`ls verify_*_out.txt 2> /dev/null`
HEADER="x86noas verify errors:"
CMD='egrep -C 3 -i "abort|error|Usage|ERROR: Can''t find " $FILE'
look_for_error

FILE=`which get_trace_count`
HEADER="Pinball/trace counts:"
CMD="$FILE $OUT_FILE"
look_for_error

rm $TMP_FILE
exit 0
